%YAML 1.2
---
name: Forge Game Data
file_extensions: [fgd]
scope: source.valve.fgd

variables:
  kvtypes: '(?i:angle|angle_negative_pitch|axis|bool|boolean|choices|color1|color255|decal|filterclass|flags|float|instance_file|instance_parm|instance_variable|int|integer|material|node_dest|node_id|npcclass|origin|particlesystem|pointentityclass|scene|scriptlist|script|sidelist|sound|sprite|string|studio|target_destination|target_name_or_class|target_source|vecline|vector|void|ehandle)'
  helpertypes_arg: '(?i:animator|bbox|color|cylinder|decal|frustum|iconsprite|instance|keyframe|light|lightcone|lightprop|line|overlay|overlay_transition|quadbounds|sidelist|size|sphere|sprite|studio|studioprop|wirebox)'
  helpertypes_no_arg: '(?i:halfgridsnap)'
  identifier: '[A-Za-z\_][A-Za-z\_\.0-9]*'

contexts:
  inc_comments:
    - match: //
      scope: punctuation.definition.comment.begin.fgd
      push: comment
  comment:
    - meta_scope: comment.line.double-slash.fgd
    - match: \)
      scope: comment.line.double-slash.fgd
    - match: \n
      pop: true

  inc_string:
    - match: \"
      scope: punctuation.definition.string.begin.fgd
      push: string

  inc_string_body:
    - match: \\.
      scope: constant.character.escape.fgd
    # End quote plus continuation line, must follow with another string.
    - match: '(")\s*(\+)'
      captures:
        1: punctuation.definition.string.end.fgd
        2: keyword.operator.arithmetic.fgd.concat
      push: 
        - match: '"'
          scope: punctuation.definition.string.begin.fgd
          pop: true
        - match: '\S.*'
          scope: invalid.illegal.fgd.no-concat

  inc_all_invalid:
    # Non-whitespace is invalid at this scope.
    - match: '\S\.*'
      scope: invalid.illegal.fgd.stray-char

  string:
    - include: inc_string_body
    - meta_scope: string.quoted.double.fgd
    - match: '"'
      scope: punctuation.definition.string.end.fgd 
      pop: true 

  inc_float:
    - match: '[+-]?([0-9]*[.])?[0-9]+'
      scope: constant.numeric.float

  unified_tags_paren:
    - include: inc_comments
    - match: \)
      scope: punctuation.section.parens.end.fgd
      pop: true
    - match: \!
      scope: keyword.operator.logical.fgd.invert
      set: unified_tags_no_invert_paren
    - match: \,
      scope: punctuation.separator.sequence.fgd
    - match: '{{identifier}}'
      scope: support.constant.fgd
      set: unified_tags_no_invert_paren
    - include: inc_all_invalid

  unified_tags_no_invert_paren:
    - include: inc_comments
    - match: \)
      scope: punctuation.section.parens.end.fgd
      pop: true
    - match: \!
      scope: invalid.illegal.stray-inverse
    - match: \,
      scope: punctuation.separator.sequence.fgd
      set: unified_tags_paren
    - match: '{{identifier}}'
      scope: support.constant.fgd
    - include: inc_all_invalid

  unified_tags_brack:
    - include: inc_comments
    - match: \]
      scope: punctuation.section.brackets.end.fgd
      pop: true
    - match: \!
      scope: keyword.operator.logical.fgd.invert
      set: unified_tags_no_invert_brack
    - match: \,
      scope: punctuation.separator.sequence.fgd
    - match: '{{identifier}}'
      scope: support.constant.fgd
      set: unified_tags_no_invert_brack
    - include: inc_all_invalid

  unified_tags_no_invert_brack:
    - include: inc_comments
    - match: \]
      scope: punctuation.section.brackets.end.fgd
      pop: true
    - match: \!
      scope: invalid.illegal.stray-inverse
    - match: \,
      scope: punctuation.separator.sequence.fgd
      set: unified_tags_brack
    - match: '{{identifier}}'
      scope: support.constant.fgd
    - include: inc_all_invalid

  main:
    - include: inc_comments
    # - match: '"'
    #   scope: punctuation.definition.string.begin.fgd
    #   push: string
    - match: '(?i:(@)(mapsize))\s*(\()'
      captures: 
        1: punctuation.definition.keyword.fgd keyword.other.fgd.mapsize
        2: keyword.other.fgd.mapsize
        3: punctuation.section.parens.begin.fgd.helper
      push: helper-args

    - match: '(?i:(@)(include))'
      captures: 
        1: punctuation.definition.keyword.fgd keyword.other.fgd.include
        2: keyword.other.fgd.include
      push: 
        - match: '"'
          scope: punctuation.definition.string.begin.fgd
          set: 
            - meta_scope: string.quoted.double.fgd.include
            - match: \\.
              scope: constant.character.escape.fgd
            - match: '"'
              scope: punctuation.definition.string.end.fgd meta.filepath.relative
              pop: true 
            # Do it this way so the punctuation is NOT meta.filepath
            - match: .
              scope: meta.filepath.relative

    - match: (?i:(@)(baseclass|solidclass|npcclass|pointclass|filterclass|keyframeclass|moveclass)\b)
      captures: 
        1: punctuation.definition.keyword.fgd keyword.other.fgd.entity
        2: keyword.other.fgd.entity
      push: entity-header

    - match: (?i:(@)(autovisgroup))
      captures:
        1: punctuation.definition.keyword.fgd keyword.other.fgd.entity
        2: keyword.other.fgd.visgroup
      push: auto-visgroup-header

    # Material exclusion, [ "strings" ]
    - match: (?i:(@)(materialexclusion))
      captures:
        1: punctuation.definition.keyword.fgd keyword.other.fgd.entity
        2: keyword.other.fgd.exclude
      push: 
        - match: \[
          scope: punctuation.section.block.begin.fgd
          set:
            - include: inc_string
            - include: inc_comments
            - match: \]
              scope: punctuation.section.block.end.fgd
              pop: true
            - include: inc_all_invalid
        - include: inc_comments
        - include: inc_all_invalid


    - match: '@'
      scope: punctuation.definition.keyword.fgd meta.fgd.keyword_start

    - include: inc_all_invalid

  entity-header:
    - meta_scope: meta.class.fgd meta.fgd.helpers
    - include: inc_comments
    - match: '='
      scope: punctuation.separator
      set: entity-name
    - match: '\]'
      scope: invalid.illegal.stray-close


    # Helpers, optionally with args.
    - match: ((?i:base))(\()
      # Special case - base gets the reference types, so you 
      # can jump to definition.
      captures:
        1: support.type.fgd.helper
        2: punctuation.section.parens.begin.fgd.helper
      push: 
        - match: '{{identifier}}'
          scope: variable.function.fgd.baseref
        - include: helper-args

    - match: ((?i:appliesto))(\()
      # Unified FGD Extension.
      captures:
        1: keyword.declaration.fgd
        2: punctuation.section.parens.begin.fgd.helper
      push: unified_tags_paren

    - match: '({{helpertypes_arg}})(\()'
      captures:
        1: support.type.fgd.helper
        2: punctuation.section.parens.begin.fgd.helper
      push: helper-args
    - match: '{{helpertypes_no_arg}}\s'
      scope: support.type.fgd.helper
    # Unknown helper.
    - match: '({{identifier}})\s*(\()'
      captures:
        1: variable.function.fgd.helper
        2: punctuation.section.parens.begin.fgd.helper
      push: helper-args
    - match: '{{identifier}}\b'
      scope: variable.function.fgd.helper

  helper-args:
    - meta_scope: meta.class.fgd
    - include: inc_comments
    - match: '\)'
      scope: punctuation.section.parens.begin.fgd.helper
      pop: true
    - match: ','
      scope: punctuation.separator.sequence.fgd
    - include: inc_float
    - include: inc_string
    - match: '{{identifier}}'
      scope: string.unquoted.fgd


  entity-name:
    - meta_scope: meta.class.fgd
    - include: inc_comments
    - match: '{{identifier}}'
      scope: entity.name.class.fgd meta.class.fgd.name 
    - match: ':'
      scope: punctuation.separator
      set:
        # Must have 1 string, then an open bracket.
        - match: \"
          set:
            - meta_scope: comment.block.documentation.fgd string.quoted.double.fgd
            - include: inc_string_body
            - match: \"
              scope: punctuation.definition.string.end.fgd 
              set: 
                - match: \[
                  scope: punctuation.section.block.begin.fgd.entity
                  set: entity-body
                - include: inc_all_invalid
        - include: inc_all_invalid
    - match: \[
      scope: punctuation.section.block.begin.fgd.entity
      set: entity-body
    - include: inc_all_invalid

  entity-body:
    - meta_scope: meta.class.fgd meta.block.fgd.entity
    - include: inc_comments

    - match: (input|output)
      scope: storage.type.fgd.io
      push: io_name
    - match: ({{identifier}})
      scope: variable.other.member.fgd.keyvalue
      push: keyvalue_pre_type
    # Complex.
    # Matches: kv_name (type) readonly/report
    
    - match: \]
      scope: punctuation.section.block.end.fgd.entity
      pop: true

  io_name:
    # Can't use this twice in a row.
    - match: (input|output)
      scope: invalid.illegal.fgd
    - match: ({{identifier}})
      scope: variable.other.member.fgd.keyvalue
      set: keyvalue_pre_type
    - include: inc_all_invalid

  keyvalue_pre_type:
    # After the idenfier, so either (type) or [tags](type)
    - match: \(
      scope: punctuation.section.parens.begin.fgd
      set: keyvalue_type
    - match: \[
      scope: punctuation.section.brackets.begin.fgd
      set: 
        - keyvalue_no_tags
        - unified_tags_brack
    - include: inc_all_invalid

  keyvalue_no_tags:
    # After tags, so must be parens.
    - match: \(
      scope: punctuation.section.parens.begin.fgd
      set: keyvalue_type
    - include: inc_all_invalid

  keyvalue_type:
    # Inside type parens.
    - match: \s*({{kvtypes}})\s*(\))(\s*(?i:readonly|report))*
      captures:
        1: support.type.fgd.type
        2: punctuation.section.parens.end.fgd
        3: keyword.control.fgd.kvalue_type
      set: keyvalue
    - include: inc_all_invalid

  # Keyvalue body, parameters.
  keyvalue:
    - match: '//'
      scope: punctuation.definition.comment.fgd
      # We need to set this, so the keyvalue scope gets popped too.
      set: comment

    - include: inc_float
    - include: inc_string
    - match: ':'
      scope: punctuation.separator.fgd.keyvalue-sep
    - match: '\n'
      pop: true    
    - match: =
      scope: punctuation.separator.fgd.choices
      set:
        - match: \[
          scope: punctuation.section.block.begin.fgd.choices
          set:
            # Choices body.
            - include: inc_comments
            - include: inc_float
            - include: inc_string
            - match: ':'
              scope: punctuation.separator.fgd.choices
            - match: \]
              scope: punctuation.section.block.end.fgd.choices
              pop: true
        - include: inc_all_invalid

  auto-visgroup-header:
    # We MUST have = "name" next.
    - match: \=
      scope: punctuation.separator.fgd
      set: 
        - match: \"
          set:
            - meta_scope: comment.block.documentation.fgd string.quoted.double.fgd
            - include: inc_string_body
            - match: \"
              scope: punctuation.definition.string.end.fgd 
              set: 
                - match: \[
                  scope: punctuation.section.block.begin.fgd.autovisgroup
                  set: auto-visgroup-body
                - include: inc_comments
                - include: inc_all_invalid
        - include: inc_all_invalid

  auto-visgroup-body:
    - include: inc_comments
    - include: inc_string
    # Exactly 1 nest only.
    - match: \[
      scope: punctuation.section.block.begin.fgd.autovisgroup
      push:
        - include: inc_comments
        - include: inc_string
        - match: '\[.*'
          scope: invalid.illegal.fgd.excess-bracket
        - match: \]
          scope: punctuation.section.block.end.fgd.autovisgroup
          pop: true
    - match: \]
      scope: punctuation.section.block.end.fgd.autovisgroup
      pop: true
