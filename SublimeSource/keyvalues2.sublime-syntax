%YAML 1.2
---
name: Keyvalues2 (DMX)
file_extensions: [dmx]
scope: source.valve.keyvalues2

variables: 
  elem_types: '(?i:binary|bool|color|element(?:id)?|float|int|qangle|quaternion|string|time|vector[234]|vmatrix)'
  bool_values: '(?i:1|0|yes|no|true|false|y|n|t|f)'
  float: '([+-])?[0-9]*([.])?[0-9]+'

contexts:
  inc_comments:
    - match: '//'
      scope: punctuation.definition.comment.keyvalues2
      push: comment
  comment:
    - meta_scope: comment.line.keyvalues2
    - match: '\n'
      pop: true

  inc_header:
    - match: '\n.*'
      scope: invalid.illegal.header


  string:
    - meta_scope: string.quoted.double.keyvalues2
    - match: \\.
      scope: constant.character.escape.keyvalues2
    - match: '"'
      scope: punctuation.definition.string.end.keyvalues2
      pop: true

  # These are pushed on top of another context, and once found is popped back to that.
  expect_string:
    - include: inc_comments
    - match: '"'
      scope: punctuation.definition.string.begin.keyvalues2  string.quoted.double
      pop: true
    - match: '\S'
      scope: invalid.illegal

  expect_string_end:
    - include: inc_comments
    - match: '"'
      scope: punctuation.definition.string.end.keyvalues2 string.quoted.double
      pop: true
    - match: '\S'
      scope: invalid.illegal

  expect_int:
    - match: '(-)?[0-9]*'
      scope: constant.numeric.integer.decimal
      captures:
        1: keyword.operator.arithmetic
      pop: true
    # If illegal is found, lookahead for all so we pop, then expect_string_end handles it.
    - match: '(?=\S)'
      pop: true

  expect_float:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      pop: true
    - match: '(?=\S)'
      scope: invalid.illegal.non-digit
      pop: true

  expect_bool:
    - meta_scope: meta.kv2.boolean
    - match: '{{bool_values}}'
      scope: constant.language.boolean
      pop: true
    - match: '[^"\s]+'
      scope: invalid.illegal.non-digit
      pop: true

  main:
    - match: '<!--'
      scope: keyword.other.namespace
      set: header_dmx
    - include: inc_header

  header_dmx:
    - match: 'dmx'
      scope: keyword.declaration.namespace
      set: header_encoding
    - match: 'DMXVersion'
      scope: keyword.declaration.namespace
    - include: inc_header

  header_encoding:
    - match: '\s+encoding'
      scope: keyword.declaration.namespace
      set: header_encoding_value
    - include: inc_header

  header_encoding_value:
    - match: '(unicode\_)?keyvalues2'
      scope: keyword.declaration.namespace
      set: header_encoding_version
    - match: '\s+[a-z0-9_]+'
      scope: string.unquoted
      set: header_encoding_version
    - include: inc_header

  header_encoding_version:
    - match: '\s+[0-9]+'
      scope: constant.numeric.integer
      set: header_format
    - include: inc_header

  header_format:
    - match: '\s+format'
      scope: keyword.declaration.namespace
      set: header_format_value
    - include: inc_header

  header_format_value:
    - match: '\s+[a-z0-9_]+'
      scope: string.unquoted
      set: header_format_version
    - include: inc_header

  header_format_version:
    - match: '\s+[0-9]+'
      scope: constant.numeric.integer
      set: header_ending
    - include: inc_header

  header_ending:
    - match: '-->'
      scope: keyword.other.namespace
      set: expect_elem
    - include: inc_header

  expect_elem: # Toplevel, needs an element name.
    - include: inc_comments
    - match: '"'
      scope: punctuation.definition.string.begin.keyvalues2
      push: [elem_brace, string]

  elem_brace:
    - include: inc_comments
    - match: '{'
      scope: punctuation.definition.braces.begin punctuation.section.block.begin meta.block
      set: elem_body

  elem_body: # The interior of an element.
    - meta_scope: meta.class.kv2-element
    - include: inc_comments
    - match: '}'
      scope: punctuation.definition.braces.end punctuation.section.block.end
      pop: true
    - match: '"'
      scope: punctuation.definition.string.begin.keyvalues2
      push: [attr_scalar, string]

  attr_scalar:
    # After an attribute name. We now expect a type + value, or element name & value.
    - meta_scope: string.quoted.double meta.kv2.typename
    - include: inc_comments

    # Array types.
    - match: 'int_array'
      scope: storage.type.scalar
      set: [array_int, array_body, array_start, expect_string_end]
    - match: 'float_array'
      scope: storage.type.scalar
      set: [array_float, array_body, array_start, expect_string_end]
    - match: 'vector2_array'
      scope: storage.type.scalar
      set: [array_float2a, array_body, array_start, expect_string_end]
    - match: '(vector3|qangle)_array'
      scope: storage.type.scalar
      set: [array_float3a, array_body, array_start, expect_string_end]
    - match: '(vector4|color|quaternion)_array'
      scope: storage.type.scalar
      set: [array_float4a, array_body, array_start, expect_string_end]
    - match: 'bool_array'
      scope: storage.type.scalar
      set: [array_bool, array_body, array_start, expect_string_end]

    - match: '({{elem_types}})(_array)'  # Array
      captures:
        1: storage.type.array
        2: storage.modifier
      set:
      - match: '"'
        scope: punctuation.definition.string.end.kv2
        set:
        - match: '\['
          scope: punctuation.definition.brackets.begin
          set:
          # TODO Arrays
          - match: '\]'
            scope: punctuation.definition.brackets.end
            pop: true

    # Scalar types.
    - match: 'int'
      scope: storage.type.scalar
      set: [expect_string_end, expect_int, expect_string, expect_string_end]
    - match: 'float'
      scope: storage.type.scalar
      set: [expect_string_end, expect_float, expect_string, expect_string_end]
    - match: 'vector2'
      scope: storage.type.scalar
      set: [expect_string_end, expect_float, expect_float, expect_string, expect_string_end]
    - match: 'vector3|qangle'
      scope: storage.type.scalar
      set: [expect_string_end, expect_float, expect_float, expect_float, expect_string, expect_string_end]
    - match: 'vector4|color|quaternion'
      scope: storage.type.scalar
      set: [expect_string_end, expect_float, expect_float, expect_float, expect_float, expect_string, expect_string_end]
    - match: 'binary'
      scope: storage.type.scalar
      set: [value_binary, expect_string, expect_string_end]
    - match: 'element(id)?'
      scope: storage.type.scalar
      set: [value_uuid, expect_string, expect_string_end]
    - match: 'bool'
      scope: storage.type.scalar
      set: [expect_string_end, expect_bool, expect_string, expect_string_end]
    - match: '{{elem_types}}'
      scope: storage.type.scalar
      # TODO proper definition instead of 1st string
      set: [string, expect_string, expect_string_end]

    # Anything else is an element type.
    - match: '[a-zA-Z_0-9]+'
      scope: entity.name.element storage.class
      set: [elem_brace, expect_string_end]

  value_binary:
    - match: '[0-9a-fA-F]'
      scope: constant.numeric.hex
    - match: '"'
      scope: punctuation.definition.string.end.keyvalues2
      pop: true
    - match: '\S'
      scope: invalid.illegal.non-digit

  value_uuid:
    - match: '[0-9a-fA-F]'
      scope: constant.numeric.hex
    - match: '-'
      scope: string.quoted.double
    - match: '"'
      scope: punctuation.definition.string.end.keyvalues2 string.quoted.double
      pop: true
    - match: '\S'
      scope: invalid.illegal.non-digit

  array_start:
    - include: inc_comments
    - match: '\['
      scope: punctuation.definition.brackets.begin
      pop: true

  # We do this weirdly - put the array body on top of the value, and pop it when inside.
  # That way we can handle commas etc in the same locs.
  # Add the array meta scope so we can suppress completions between values.
  array_body:
    - meta_scope: meta.kv2.array
    - include: inc_comments
    - match: '"'
      scope: punctuation.definition.string.begin.keyvalues2 string.quoted.double
      pop: true # Back to value context.
    - match: ','
      scope: invalid.illegal
    - match: '\]'
      scope: punctuation.definition.brackets.end
      pop: 2 # Array and value context

  array_comma:
    - meta_scope: meta.kv2.array
    - match: ','
      scope: punctuation.separator.sequence.keyvalues2
      set: array_body
    - match: '"'
      scope: invalid.illegal
      pop: 2  # Treat as a value anyway.
    - match: '(?=])'
      set: array_body  # If we're ending, pop so array_body can handle.

  inc_array_value:
    - match: '"'
      scope: punctuation.definition.string.end.keyvalues2 string.quoted.double
      set: array_body
      # If illegal is found, push the body to handle it.
    - match: '(?=\S)'
      push: array_body

  array_value_end:
    - match: '"'
      scope: punctuation.definition.string.end.keyvalues2 string.quoted.double
      set: array_comma
    - match: '\S'
      scope: invalid.illegal

  array_int:
    - match: '(-)?[0-9]*'
      scope: constant.numeric.integer.decimal
      captures:
        1: keyword.operator.arithmetic
      push: array_value_end
    - include: inc_array_value

  array_float:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      push: array_value_end
    - include: inc_array_value

  array_bool:
    - meta_scope: meta.kv2.boolean
    - match: '{{bool_values}}'
      scope: constant.language.boolean
      push: array_value_end
    - include: inc_array_value

  # Sadness, we need to manually handle these contexts so we can reset the number seen
  # when reaching the end.
  array_float2a:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: array_float2b
    - include: inc_array_value

  array_float2b:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: [array_float2a, array_value_end]
    - match: '(?=\S)'
      set: [array_float2a, array_body]
    - include: inc_array_value


  array_float3a:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: array_float3b
    - include: inc_array_value

  array_float3b:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: array_float3c
    - match: '(?=\S)'
      set: [array_float3a, array_body]
    - include: inc_array_value

  array_float3c:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: [array_float3a, array_value_end]
    - match: '(?=\S)'
      set: [array_float3a, array_body]
    - include: inc_array_value


  array_float4a:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: array_float4b
    - include: inc_array_value

  array_float4b:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: array_float4c
    - match: '(?=\S)'
      set: [array_float4a, array_body]
    - include: inc_array_value

  array_float4c:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: array_float4d
    - match: '(?=\S)'
      set: [array_float4a, array_body]
    - include: inc_array_value

  array_float4d:
    - match: '{{float}}'
      scope: constant.numeric.float
      captures:
        1: keyword.operator.arithmetic
        2: punctuation.separator.decimal
      set: [array_float4a, array_value_end]
    - match: '(?=\S)'
      set: [array_float4a, array_body]
    - include: inc_array_value
